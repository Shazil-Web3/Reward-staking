require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { createClient } = require('@supabase/supabase-js');
const { ethers } = require('ethers');
const moralisService = require('./services/moralis-service');
const crypto = require('crypto');
const { MerkleTree } = require('merkletreejs');
const { keccak256, solidityPackedKeccak256 } = require('ethers');
const { CCT_DECIMALS, USDT_DECIMALS } = require('./config/constants');

const app = express();
const PORT = process.env.PORT || 3001;

// Initialize Supabase
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

app.use(cors());
app.use(express.json());

// Initialize Moralis Service
moralisService.initialize();

// --- API ENDPOINTS ---

/**
 * POST /api/deposits/create
 * Creates a pending deposit order. 
 * Frontend calls this BEFORE user sends transaction to get a unique Order ID.
 */
app.post('/api/deposits/create', async (req, res) => {
    try {
        const { walletAddress, amount, referralCode } = req.body;

        if (!walletAddress || !amount) {
            return res.status(400).json({ error: 'Wallet address and amount required' });
        }

        // Generate unique Order ID (random hex string that fits in bytes32)
        const orderIdBytes = crypto.randomBytes(32).toString('hex');
        const orderId = '0x' + orderIdBytes;

        const { data, error } = await supabase
            .from('deposits')
            .insert({
                order_id: orderId,
                user_address: walletAddress.toLowerCase(),
                amount: amount,
                referral_code: referralCode,
                status: 'pending'
            })
            .select()
            .single();

        if (error) throw error;

        res.json({ success: true, orderId: orderId });

    } catch (error) {
        console.error('Error creating deposit:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/deposits/track
 * Records an on-chain deposit that was generated by the frontend.
 * Accepts the frontend-generated orderId.
 */
app.post('/api/deposits/track', async (req, res) => {
    try {
        const { orderId, walletAddress, amount, cctAmount, lockYears, referralCode, txHash } = req.body;

        if (!orderId || !walletAddress || !amount) {
            return res.status(400).json({ error: 'Order ID, Wallet Address and Amount required' });
        }

        console.log(`ðŸ“ Tracking Deposit: ${orderId} | Hash: ${txHash}`);

        // 0. VERIFY TRANSACTION via Moralis (Generates the logs user wants!)
        // This ensures the TX is real and successful before we save it.
        const verification = await moralisService.verifyDepositTransaction(txHash, orderId);
        
        if (!verification.verified) {
            console.error(`âŒ Validation Failed for ${txHash}: ${verification.error}`);
            // We can return 400, or save as 'rejected' for debug. Returning error is safer to prevent junk data.
            return res.status(400).json({ error: `Verification Failed: ${verification.error}` });
        }
        
        console.log(`âœ… Transaction Verified on Chain! Block: ${verification.blockNumber}`);

        // 1. Ensure User Exists in DB (to satisfy Foreign Key)
        let { data: userCheck } = await supabase
            .from('users')
            .select('*')
            .eq('wallet_address', walletAddress.toLowerCase())
            .single();

        if (!userCheck) {
            console.log(`Creating new user record for ${walletAddress}`);
            
            // Generate referral code: Last 6 digits of wallet (User Request)
            const newReferralCode = walletAddress.slice(-6).toUpperCase();
            
            const { data: newUser, error: userError } = await supabase
                .from('users')
                .insert({ 
                    wallet_address: walletAddress.toLowerCase(),
                    referral_code: newReferralCode,
                    created_at: new Date().toISOString(),
                    total_deposited_usdt: 0
                })
                .select()
                .single();
            
            if (userError) {
                console.error("Error creating user:", userError);
            } else {
                userCheck = newUser;
            }
        }

        // 2. Insert Deposit
        const { data, error } = await supabase
            .from('deposits')
            .insert({
                order_id: orderId,
                user_address: walletAddress.toLowerCase(),
                amount: amount,
                referral_code: referralCode,
                tx_hash: txHash,
                status: 'verified', // It's on-chain, so it is effectively verified/submitted
                verified_at: new Date().toISOString()
            })
            .select()
            .single();

        if (error) throw error;
        
        // 3. Update User's Total Staked (USDT)
        if (userCheck) {
            const currentTotal = parseFloat(userCheck.total_deposited_usdt || 0);
            const depositAmount = parseFloat(amount || 0);
            const newTotal = currentTotal + depositAmount;
            
            await supabase
                .from('users')
                .update({ total_deposited_usdt: newTotal })
                .eq('wallet_address', walletAddress.toLowerCase());
                
            console.log(`Updated total_deposited_usdt for ${walletAddress}: ${currentTotal} -> ${newTotal}`);
        }

        // Handle referrals if code provided
        if (referralCode) {
            await handleReferral(walletAddress, referralCode, orderId);
        }

        res.json({ success: true, deposit: data });

    } catch (error) {
        console.error('Error tracking deposit:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/referral/resolve/:code
 * Resolves a referral code to a wallet address.
 */
app.get('/api/referral/resolve/:code', async (req, res) => {
    try {
        const codeInput = req.params.code.trim();
        let query = supabase.from('users').select('wallet_address, referral_code');

        // Check if input looks like an address (Case Insensitive check)
        if (codeInput.startsWith('0x') && codeInput.length === 42) {
             query = query.eq('wallet_address', codeInput.toLowerCase());
        } else {
             // Assume it's a code
             query = query.ilike('referral_code', codeInput);
        }

        const { data: user, error } = await query.single();
            
        if (user) {
            return res.json({ 
                walletAddress: user.wallet_address,
                referralCode: user.referral_code
            });
        }
        
        return res.status(404).json({ error: 'Referral code or user not found' });
    } catch (e) {
        console.error("Resolve error:", e);
        res.status(500).json({ error: e.message });
    }
});


/**
 * POST /api/deposits/verify
 * Verifies a transaction hash submitted by the user.
 * 1. Checks transaction via Moralis
 * 2. Matches with Order ID
 * 3. Updates database status to 'verified'
 * 4. Records referral connection
 */
 app.post('/api/deposits/verify', async (req, res) => {
    try {
        const { orderId, txHash } = req.body;

        if (!orderId || !txHash) {
            return res.status(400).json({ error: 'Order ID and Transaction Hash required' });
        }

        // 1. Verify via Moralis (One API Call)
        const verification = await moralisService.verifyDepositTransaction(txHash, orderId);

        if (!verification.verified) {
            return res.status(400).json({ verified: false, error: verification.error });
        }

        // 2. Verified! Update Database
        const { data: deposit, error: dbError } = await supabase
            .from('deposits')
            .update({
                status: 'verified', // Verified by blockchain, needs admin approval
                tx_hash: txHash,
                verified_at: new Date().toISOString(),
                block_number: verification.blockNumber,
                amount: verification.amount // Update with actual verified amount
            })
            .eq('order_id', orderId)
            .select()
            .single();

        if (dbError) throw dbError;

        // 3. Handle Referrals (Backend Logic)
        if (verification.referralCode) {
            await handleReferral(verification.userAddress, verification.referralCode, orderId);
        }

        // 4. Update User's Total Staked
        // CRITICAL FIX: Ensure verify endpoint also updates stats
        const { data: userStats } = await supabase
            .from('users')
            .select('*')
            .eq('wallet_address', verification.userAddress.toLowerCase())
            .single();

        if (userStats) {
            const currentTotal = parseFloat(userStats.total_deposited_usdt || 0);
            const depositAmount = parseFloat(verification.amount || 0);
            const newTotal = currentTotal + depositAmount;
            
            await supabase
                .from('users')
                .update({ total_deposited_usdt: newTotal })
                .eq('wallet_address', verification.userAddress.toLowerCase());
                
            console.log(`[Verify] Updated total_deposited_usdt for ${verification.userAddress}: ${currentTotal} -> ${newTotal}`);
        }

        res.json({ 
            success: true, 
            verified: true, 
            deposit: deposit 
        });

    } catch (error) {
        console.error('Verification error:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/admin/deposits/pending
 * Returns all verified deposits waiting for admin approval
 */
app.get('/api/admin/deposits/pending', async (req, res) => {
    try {
        const { data, error } = await supabase
            .from('deposits')
            .select('*')
            .eq('status', 'verified')
            .order('verified_at', { ascending: false });

        if (error) throw error;
        res.json(data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/admin/deposits/approve/:orderId
 * Admin approves the deposit.
 * - Updates status to 'approved'
 * - Calculates CCT token allocation
 * - (Optional) Triggers Escrow Contract to add stake
 */
app.post('/api/admin/deposits/approve/:orderId', async (req, res) => {
    try {
        const { orderId } = req.params;
        const { tokensAllocated } = req.body; 
        
        if (!tokensAllocated) return res.status(400).json({ error: 'Token allocation required' });

        // Update deposit status
        const { data, error } = await supabase
            .from('deposits')
            .update({
                status: 'approved',
                approved_at: new Date().toISOString(),
                tokens_allocated: tokensAllocated
            })
            .eq('order_id', orderId)
            .select()
            .single();

        if (error) throw error;

        res.json({ success: true, deposit: data });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/admin/recalculate-totals
 * Helper to fix missing user totals (Run once)
 */
app.get('/api/admin/recalculate-totals', async (req, res) => {
    try {
        console.log("ðŸ”„ Starting Total Staked Recalculation...");
        
        // 1. Fetch all verified/approved deposits
        const { data: deposits, error } = await supabase
            .from('deposits')
            .select('user_address, amount')
            .in('status', ['verified', 'approved']);
            
        if (error) throw error;
        
        // 2. Aggregate Totals
        const userTotals = {};
        deposits.forEach(d => {
            const addr = d.user_address.toLowerCase();
            const amt = parseFloat(d.amount);
            userTotals[addr] = (userTotals[addr] || 0) + amt;
            console.log(`User ${addr}: +${amt} => ${userTotals[addr]}`);
        });

        // 3. Update Users Table
        let updateCount = 0;
        for (const [address, total] of Object.entries(userTotals)) {
            const { error: updateError } = await supabase
                .from('users')
                .update({ total_deposited_usdt: total })
                .eq('wallet_address', address);
                
            if (updateError) console.error(`Failed update for ${address}:`, updateError);
            else updateCount++;
        }
        
        console.log(`âœ… Recalculated totals for ${updateCount} users.`);
        res.json({ success: true, updatedUsers: updateCount, totals: userTotals });
        
    } catch (error) {
        console.error("Recalculation error:", error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/referrals/tree/:address
 * Get referral stats for a user
 */
app.get('/api/referrals/tree/:address', async (req, res) => {
    try {
        const address = req.params.address.toLowerCase();
        const counts = await getReferralCounts(address);

        res.json({
            address: address,
            directReferrals: counts.direct,
            indirectReferrals: counts.indirect,
            totalReferrals: counts.total
        });

    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// --- NEW ROUTES FOR WALLET & REWARDS ---

/**
 * POST /api/wallet/register
 * Ensures user exists in DB when they connect wallet.
 */
app.post('/api/wallet/register', async (req, res) => {
    try {
        const { walletAddress } = req.body;
        if (!walletAddress) return res.status(400).json({ error: 'Wallet address required' });

        const { data: user } = await supabase
            .from('users')
            .select('wallet_address')
            .eq('wallet_address', walletAddress.toLowerCase())
            .single();

        if (!user) {
            console.log(`Registering new user: ${walletAddress}`);
            // Generate referral code: Last 6 digits of wallet (User Request)
            const newReferralCode = walletAddress.slice(-6).toUpperCase();
            
            const { error } = await supabase.from('users').insert({
                wallet_address: walletAddress.toLowerCase(),
                referral_code: newReferralCode,
                created_at: new Date().toISOString()
            });
            if (error) throw error;
        }

        res.json({ success: true });
    } catch (error) {
        console.error('Wallet register error:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/rewards/proof/:address/latest
 * Returns Merkle proof for Standard Rewards.
 * Currently returns "Not Eligible" as default until Merkle logic is integrated.
 */
app.get('/api/rewards/proof/:address/latest', async (req, res) => {
    // TODO: Maintain compatibility but this should query reward_entries
     try {
        const address = req.params.address.toLowerCase();
        
        // 1. Check User Eligibility (Referrals)
        const { data: user } = await supabase
            .from('users')
            .select('total_deposited_usdt, direct_referrals_count')
            .eq('wallet_address', address)
            .single();

        let isEligible = false;
        if (user) {
            const staked = parseFloat(user.total_deposited_usdt || 0);
            const refs = user.direct_referrals_count || 0;
            // Logic: $100+ needs 5 refs, <$100 needs 10 refs
            const target = staked >= 100 ? 5 : 10;
            if (refs >= target) {
                isEligible = true;
            }
        }

        // 2. Find stored reward entry
        const { data: entry } = await supabase
            .from('reward_entries')
            .select('*')
            .eq('user_address', address)
            .eq('pool_name', 'Standard')
            .order('epoch_id', { ascending: false })
            .limit(1)
            .single();

        if (entry && isEligible) {
            res.json({ 
                eligible: true, 
                amount: entry.amount, 
                proof: entry.proof, 
                epochId: entry.epoch_id,
                claimed: entry.status === 'claimed'
            });
        } else {
             // Return reason for debug if needed, but keeping schema
             res.json({ eligible: false, amount: 0, proof: [], epochId: null });
        }
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

/**
 * GET /api/vip/proof/:address/latest
 * Returns Merkle proof for VIP Rewards.
 */
app.get('/api/vip/proof/:address/latest', async (req, res) => {
    try {
        const address = req.params.address.toLowerCase();
        const counts = await getReferralCounts(address);
        
        // Find proof
        const { data: entry } = await supabase
            .from('reward_entries')
            .select('*')
            .eq('user_address', address)
            .eq('pool_name', 'VIP')
            .order('epoch_id', { ascending: false })
            .limit(1)
            .single();

        if (entry) {
            res.json({ 
                eligible: true, 
                amount: entry.amount, 
                proof: entry.proof, 
                epochId: entry.epoch_id,
                claimed: entry.status === 'claimed',
                totalReferrals: counts.total,
                directReferrals: counts.direct, 
                indirectReferrals: counts.indirect 
            });
        } else {
            res.json({ 
                eligible: false, 
                amount: 0, 
                proof: [], 
                epochId: null,
                totalReferrals: counts.total,
                directReferrals: counts.direct, 
                indirectReferrals: counts.indirect 
            });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/rewards/mark-claimed
 */
app.post('/api/rewards/mark-claimed', async (req, res) => {
    try {
        const { walletAddress, epochId } = req.body;
        
        const { error } = await supabase
            .from('reward_entries')
            .update({ status: 'claimed' })
            .eq('user_address', walletAddress.toLowerCase())
            .eq('epoch_id', epochId)
            .eq('pool_name', 'Standard');
            
        if (error) throw error;

        res.json({ success: true });
    } catch (e) { 
        console.error("Error marking reward claimed:", e);
        res.status(500).json({ error: e.message }); 
    }
});

/**
 * POST /api/vip/mark-claimed
 */
app.post('/api/vip/mark-claimed', async (req, res) => {
    try {
        const { walletAddress, epochId } = req.body;
        
        const { error } = await supabase
            .from('reward_entries')
            .update({ status: 'claimed' })
            .eq('user_address', walletAddress.toLowerCase())
            .eq('epoch_id', epochId)
            .eq('pool_name', 'VIP');
            
        if (error) throw error;

        res.json({ success: true });
    } catch (e) { 
        console.error("Error marking VIP reward claimed:", e);
        res.status(500).json({ error: e.message }); 
    }
});

// Helper: Get Referral Counts (Direct + Indirect)
async function getReferralCounts(walletAddress) {
    try {
        const address = walletAddress.toLowerCase();
        
        // Count Level 1 (direct)
        const { count: directCount } = await supabase
            .from('referrals')
            .select('*', { count: 'exact', head: true })
            .eq('referrer_address', address)
            .eq('level', 1);
        
        // Count Level 2 (indirect)  
        const { count: indirectCount } = await supabase
            .from('referrals')
            .select('*', { count: 'exact', head: true })
            .eq('referrer_address', address)
            .eq('level', 2);
        
        return {
            direct: directCount || 0,
            indirect: indirectCount || 0,
            total: (directCount || 0) + (indirectCount || 0)
        };
    } catch (error) {
        console.error('Error getting referral counts:', error);
        return { direct: 0, indirect: 0, total: 0 };
    }
}

// Helper: Handle Referral Logic
async function handleReferral(userAddressRaw, referralCode, depositId) {
    try {
        const userAddress = userAddressRaw.toLowerCase();

        // 0. CHECK IF USER ALREADY HAS A REFERRER
        const { data: currentUser } = await supabase
             .from('users')
             .select('referrer_address')
             .eq('wallet_address', userAddress)
             .single();

        if (currentUser && currentUser.referrer_address) {
             console.log(`â„¹ï¸ User ${userAddress} already has a referrer. Skipping referral logic.`);
             return;
        }

        // 1. Find Referrer by Code
        const { data: referrerUser } = await supabase
            .from('users')
            .select('wallet_address, referrer_address')
            .eq('referral_code', referralCode)
            .single();

        if (!referrerUser) return; // Invalid code, skip

        const referrerAddress = referrerUser.wallet_address;
        
        // Prevent self-referral
        if (referrerAddress.toLowerCase() === userAddress.toLowerCase()) return;

        // 2. Insert Level 1 Referral
        await supabase.from('referrals').insert({
            deposit_id: depositId,
            user_address: userAddress,
            referrer_address: referrerAddress,
            level: 1,
            status: 'pending'
        });

        // 3. Insert Level 2 Referral (if referrer has a referrer)
        if (referrerUser.referrer_address) {
            await supabase.from('referrals').insert({
                deposit_id: depositId,
                user_address: userAddress,
                referrer_address: referrerUser.referrer_address,
                level: 2,
                status: 'pending'
            });
        }
        
        // 4. Update Referrer Link in Users Table (if not set)
        const { data: updatedUser, error: linkError } = await supabase
            .from('users')
            .update({ referrer_address: referrerAddress })
            .eq('wallet_address', userAddress)
            .is('referrer_address', null)
            .select();

        if (updatedUser && updatedUser.length > 0) {
            console.log(`ðŸ”— Linked ${userAddress} to referrer ${referrerAddress}`);
            
            // Increment Direct Referrals Count for the Referrer
            // We fetch the current count first to be safe
            const { data: currentReferrer } = await supabase
                .from('users')
                .select('direct_referrals_count')
                .eq('wallet_address', referrerAddress)
                .single();
                
            if (currentReferrer) {
                const newCount = (currentReferrer.direct_referrals_count || 0) + 1;
                await supabase
                    .from('users')
                    .update({ direct_referrals_count: newCount })
                    .eq('wallet_address', referrerAddress);
                console.log(`ðŸ“ˆ Incremented referral count for ${referrerAddress} to ${newCount}`);
            }
        } else {
             console.log(`â„¹ï¸ User ${userAddress} already has a referrer or update failed.`);
        }

    } catch (error) {
        console.error('Referral handling error:', error);
    }
}

/**
 * GET /api/admin/rewards/eligible-count
 * Count eligible users for Standard reward pool
 */
app.get('/api/admin/rewards/eligible-count', async (req, res) => {
    try {
        // Count users with at least one verified/approved deposit (active stakers)
        const { data: activeStakers, error } = await supabase
            .from('deposits')
            .select('user_address')
            .in('status', ['verified', 'approved']);
        
        if (error) throw error;
        
        // Get unique users
        const uniqueUsers = [...new Set(activeStakers.map(d => d.user_address))];
        
        res.json({ 
            eligibleCount: uniqueUsers.length,
            users: uniqueUsers
        });
    } catch (error) {
        console.error('Error counting eligible users:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/admin/vip/eligible-count  
 * Count eligible users for VIP reward pool (100+ referrals)
 */
app.get('/api/admin/vip/eligible-count', async (req, res) => {
    try {
        // Get all users
        const { data: users, error } = await supabase
            .from('users')
            .select('wallet_address');
            
        if (error) throw error;
        
        // Check referral counts for each
        const vipUsers = [];
        for (const user of users) {
            const counts = await getReferralCounts(user.wallet_address);
            if (counts.total >= 100) {
                vipUsers.push({
                    wallet_address: user.wallet_address,
                    total_referrals: counts.total
                });
            }
        }
        
        res.json({ 
            eligibleCount: vipUsers.length,
            users: vipUsers
        });
    } catch (error) {
        console.error('Error counting VIP eligible users:', error);
        res.status(500).json({ error: error.message });
    }
});


// Helper: Generate Merkle Tree & Save Epoch
async function generateAndSaveEpoch(users, totalAmountWei, type = 'standard') {
    // 1. Get next epoch ID
    // Check if table exists implicitly by trying select
    // We assume 'reward_entries' exists. If not, this throws error.
    const { data: lastEpoch, error: epochError } = await supabase
        .from('reward_entries')
        .select('epoch_id')
        .eq('pool_name', type)
        .order('epoch_id', { ascending: false })
        .limit(1);
        
    // Handle single result logic more safely manually
    const lastRow = (lastEpoch && lastEpoch.length > 0) ? lastEpoch[0] : null;
    
    let nextEpochId = 1;
    if (lastRow) {
        nextEpochId = (lastRow.epoch_id || 0) + 1;
    }

    const amountPerUser = BigInt(totalAmountWei) / BigInt(users.length);

    console.log(`Generating ${type} Epoch ${nextEpochId} for ${users.length} users. Amount/User: ${amountPerUser}`);

    // 2. Prepare Leaves & Entries
    const entries = users.map(user => ({
        user_address: user.wallet_address || user, // Handle object or string
        epoch_id: nextEpochId,
        amount: amountPerUser.toString(),
        pool_name: type,
        status: 'pending'
    }));

    // 3. Insert into DB (Init)
    const { error: insertError } = await supabase.from('reward_entries').insert(entries);
    if (insertError) {
        console.error('Error inserting reward entries (table might be missing?):', insertError);
        throw new Error(`DB Error inserting entries: ${insertError.message}`);
    }

    // 4. Generate Tree
    // Leaf: keccak256(user, epochId, amount)
    const leaves = entries.map(e => {
        return ethers.solidityPackedKeccak256(
            ['address', 'uint256', 'uint256'],
            [e.user_address, e.epoch_id, e.amount]
        );
    });

    const tree = new MerkleTree(leaves, ethers.keccak256, { 
        sortPairs: true,
        hashLeaves: false 
    });
    
    const root = tree.getHexRoot();

    // 5. Update Proofs in DB
    for (let i = 0; i < entries.length; i++) {
        const proof = tree.getHexProof(leaves[i]);
        console.log(`Leaf ${i}: User ${entries[i].user_address} | Proof Length: ${proof.length}`);
        
        const { error: updateError, count } = await supabase
            .from('reward_entries')
            .update({ 
                proof: proof,
                merkle_root: root
            })
            .eq('user_address', entries[i].user_address)
            .eq('epoch_id', nextEpochId)
            .eq('pool_name', type);
            
        if (updateError) {
             console.error(`âŒ Failed to update proof for ${entries[i].user_address}:`, updateError);
        } else {
             // console.log(`âœ… Updated proof for ${entries[i].user_address}`);
        }
    }

    return { merkleRoot: root, epochId: nextEpochId, count: users.length };
}

/**
 * POST /api/admin/generate-epoch
 * Generate Merkle Tree for Standard Rewards
 */
app.post('/api/admin/generate-epoch', async (req, res) => {
    try {
        const { totalAmount } = req.body;
        if (!totalAmount) return res.status(400).json({ error: 'Total amount required' });

        // 1. Get Eligible Users
        const { data: activeStakers, error } = await supabase
            .from('deposits')
            .select('user_address')
            .in('status', ['verified', 'approved']);
            
        if (error) throw error;
        const uniqueUsers = [...new Set(activeStakers.map(d => d.user_address))];

        if (uniqueUsers.length === 0) return res.status(400).json({ error: 'No eligible users found' });

        // 2. Generate
        const result = await generateAndSaveEpoch(uniqueUsers, totalAmount, 'Standard');
        
        res.json(result);

    } catch (error) {
        console.error('Generate Epoch Error:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/admin/generate-vip-epoch
 * Generate Merkle Tree for VIP Rewards
 */
app.post('/api/admin/generate-vip-epoch', async (req, res) => {
    try {
        const { totalAmount } = req.body;
        if (!totalAmount) return res.status(400).json({ error: 'Total amount required' });

        // 1. Get All Users
        const { data: users, error } = await supabase.from('users').select('wallet_address');
        if (error) throw error;

        // 2. Filter VIPs (100+ Referrals)
        const vipUsers = [];
        for (const user of users) {
             const counts = await getReferralCounts(user.wallet_address);
             if (counts.total >= 100) {
                 vipUsers.push(user.wallet_address); 
             }
        }

        if (vipUsers.length === 0) return res.status(400).json({ error: 'No VIP users found' });

        // 3. Generate
        const result = await generateAndSaveEpoch(vipUsers, totalAmount, 'VIP');
        
        res.json(result);

    } catch (error) {
        console.error('Generate VIP Epoch Error:', error);
        res.status(500).json({ error: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`ðŸš€ API Server running on port ${PORT}`);
    console.log(`âœ… Manual Deposit System Active`);
});
