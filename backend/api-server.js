require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { createClient } = require('@supabase/supabase-js');
const { ethers } = require('ethers');
const moralisService = require('./services/moralis-service');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3001;

// Initialize Supabase
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY;
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

app.use(cors());
app.use(express.json());

// Initialize Moralis Service
moralisService.initialize();

// --- API ENDPOINTS ---

/**
 * POST /api/deposits/create
 * Creates a pending deposit order. 
 * Frontend calls this BEFORE user sends transaction to get a unique Order ID.
 */
app.post('/api/deposits/create', async (req, res) => {
    try {
        const { walletAddress, amount, referralCode } = req.body;

        if (!walletAddress || !amount) {
            return res.status(400).json({ error: 'Wallet address and amount required' });
        }

        // Generate unique Order ID (random hex string that fits in bytes32)
        const orderIdBytes = crypto.randomBytes(32).toString('hex');
        const orderId = '0x' + orderIdBytes;

        const { data, error } = await supabase
            .from('deposits')
            .insert({
                order_id: orderId,
                user_address: walletAddress.toLowerCase(),
                amount: amount,
                referral_code: referralCode,
                status: 'pending'
            })
            .select()
            .single();

        if (error) throw error;

        res.json({ success: true, orderId: orderId });

    } catch (error) {
        console.error('Error creating deposit:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/deposits/track
 * Records an on-chain deposit that was generated by the frontend.
 * Accepts the frontend-generated orderId.
 */
app.post('/api/deposits/track', async (req, res) => {
    try {
        const { orderId, walletAddress, amount, cctAmount, lockYears, referralCode, txHash } = req.body;

        if (!orderId || !walletAddress || !amount) {
            return res.status(400).json({ error: 'Order ID, Wallet Address and Amount required' });
        }

        console.log(`ðŸ“ Tracking Deposit: ${orderId} | Hash: ${txHash}`);

        // 0. VERIFY TRANSACTION via Moralis (Generates the logs user wants!)
        // This ensures the TX is real and successful before we save it.
        const verification = await moralisService.verifyDepositTransaction(txHash, orderId);
        
        if (!verification.verified) {
            console.error(`âŒ Validation Failed for ${txHash}: ${verification.error}`);
            // We can return 400, or save as 'rejected' for debug. Returning error is safer to prevent junk data.
            return res.status(400).json({ error: `Verification Failed: ${verification.error}` });
        }
        
        console.log(`âœ… Transaction Verified on Chain! Block: ${verification.blockNumber}`);

        // 1. Ensure User Exists in DB (to satisfy Foreign Key)
        const { data: userCheck } = await supabase
            .from('users')
            .select('wallet_address')
            .eq('wallet_address', walletAddress.toLowerCase())
            .single();

        if (!userCheck) {
            console.log(`Creating new user record for ${walletAddress}`);
            
            // Generate random referral code (8 chars)
            const newReferralCode = crypto.randomBytes(4).toString('hex');
            
            const { error: userError } = await supabase
                .from('users')
                .insert({ 
                    wallet_address: walletAddress.toLowerCase(),
                    referral_code: newReferralCode,
                    // created_at will default to now() if omitted, or use consistent naming
                    created_at: new Date().toISOString()
                });
            
            if (userError) {
                console.error("Error creating user:", userError);
                // Continue anyway? If using Service Key, maybe verify if check failed purely due to "not found" vs "error"
            }
        }

        // 2. Insert Deposit
        const { data, error } = await supabase
            .from('deposits')
            .insert({
                order_id: orderId,
                user_address: walletAddress.toLowerCase(),
                amount: amount,
                // We might want to store cctAmount/lockYears in a metadata column if schema supports it, 
                // or just basic info for now. Assuming schema has basic fields.
                referral_code: referralCode,
                tx_hash: txHash,
                status: 'verified', // It's on-chain, so it is effectively verified/submitted
                verified_at: new Date().toISOString()
            })
            .select()
            .single();

        if (error) throw error;

        // Handle referrals if code provided
        if (referralCode) {
            await handleReferral(walletAddress, referralCode, orderId);
        }

        res.json({ success: true, deposit: data });

    } catch (error) {
        console.error('Error tracking deposit:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/deposits/verify
 * Verifies a transaction hash submitted by the user.
 * 1. Checks transaction via Moralis
 * 2. Matches with Order ID
 * 3. Updates database status to 'verified'
 * 4. Records referral connection
 */
app.post('/api/deposits/verify', async (req, res) => {
    try {
        const { orderId, txHash } = req.body;

        if (!orderId || !txHash) {
            return res.status(400).json({ error: 'Order ID and Transaction Hash required' });
        }

        // 1. Verify via Moralis (One API Call)
        const verification = await moralisService.verifyDepositTransaction(txHash, orderId);

        if (!verification.verified) {
            return res.status(400).json({ verified: false, error: verification.error });
        }

        // 2. Verified! Update Database
        const { data: deposit, error: dbError } = await supabase
            .from('deposits')
            .update({
                status: 'verified', // Verified by blockchain, needs admin approval
                tx_hash: txHash,
                verified_at: new Date().toISOString(),
                block_number: verification.blockNumber,
                amount: verification.amount // Update with actual verified amount
            })
            .eq('order_id', orderId)
            .select()
            .single();

        if (dbError) throw dbError;

        // 3. Handle Referrals (Backend Logic)
        if (verification.referralCode) {
            await handleReferral(verification.userAddress, verification.referralCode, orderId);
        }

        res.json({ 
            success: true, 
            verified: true, 
            deposit: deposit 
        });

    } catch (error) {
        console.error('Verification error:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/admin/deposits/pending
 * Returns all verified deposits waiting for admin approval
 */
app.get('/api/admin/deposits/pending', async (req, res) => {
    try {
        const { data, error } = await supabase
            .from('deposits')
            .select('*')
            .eq('status', 'verified')
            .order('verified_at', { ascending: false });

        if (error) throw error;
        res.json(data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * POST /api/admin/deposits/approve/:orderId
 * Admin approves the deposit.
 * - Updates status to 'approved'
 * - Calculates CCT token allocation
 * - (Optional) Triggers Escrow Contract to add stake
 */
app.post('/api/admin/deposits/approve/:orderId', async (req, res) => {
    try {
        const { orderId } = req.params;
        const { tokensAllocated } = req.body; 

        if (!tokensAllocated) return res.status(400).json({ error: 'Token allocation required' });

        // Update deposit status
        const { data, error } = await supabase
            .from('deposits')
            .update({
                status: 'approved',
                approved_at: new Date().toISOString(),
                tokens_allocated: tokensAllocated
            })
            .eq('order_id', orderId)
            .select()
            .single();

        if (error) throw error;

        res.json({ success: true, deposit: data });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/referrals/tree/:address
 * Get referral stats for a user
 */
app.get('/api/referrals/tree/:address', async (req, res) => {
    try {
        const address = req.params.address.toLowerCase();

        // Count level 1
        const { count: level1Count, error: err1 } = await supabase
            .from('referrals')
            .select('*', { count: 'exact', head: true })
            .eq('referrer_address', address)
            .eq('level', 1);

        // Count level 2
        const { count: level2Count, error: err2 } = await supabase
            .from('referrals')
            .select('*', { count: 'exact', head: true })
            .eq('referrer_address', address)
            .eq('level', 2);

        if (err1 || err2) throw err1 || err2;

        res.json({
            address: address,
            directReferrals: level1Count,
            indirectReferrals: level2Count,
            totalReferrals: level1Count + level2Count
        });

    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// --- NEW ROUTES FOR WALLET & REWARDS ---

/**
 * POST /api/wallet/register
 * Ensures user exists in DB when they connect wallet.
 */
app.post('/api/wallet/register', async (req, res) => {
    try {
        const { walletAddress } = req.body;
        if (!walletAddress) return res.status(400).json({ error: 'Wallet address required' });

        const { data: user } = await supabase
            .from('users')
            .select('wallet_address')
            .eq('wallet_address', walletAddress.toLowerCase())
            .single();

        if (!user) {
            console.log(`Registering new user: ${walletAddress}`);
            const newReferralCode = crypto.randomBytes(4).toString('hex');
            const { error } = await supabase.from('users').insert({
                wallet_address: walletAddress.toLowerCase(),
                referral_code: newReferralCode,
                created_at: new Date().toISOString()
            });
            if (error) throw error;
        }

        res.json({ success: true });
    } catch (error) {
        console.error('Wallet register error:', error);
        res.status(500).json({ error: error.message });
    }
});

/**
 * GET /api/rewards/proof/:address/latest
 * Returns Merkle proof for Standard Rewards.
 * Currently returns "Not Eligible" as default until Merkle logic is integrated.
 */
app.get('/api/rewards/proof/:address/latest', async (req, res) => {
    // TODO: Integrate actual Merkle Tree generation/lookup
    res.json({ eligible: false, amount: 0, proof: [], epochId: null });
});

/**
 * GET /api/vip/proof/:address/latest
 * Returns Merkle proof for VIP Rewards.
 */
app.get('/api/vip/proof/:address/latest', async (req, res) => {
    // TODO: Integrate actual Merkle Tree generation/lookup
    res.json({ 
        eligible: false, 
        amount: 0, 
        proof: [], 
        epochId: null,
        totalReferrals: 0,
        directReferrals: 0, 
        indirectReferrals: 0 
    });
});

/**
 * POST /api/rewards/mark-claimed
 */
app.post('/api/rewards/mark-claimed', async (req, res) => {
    try {
        const { walletAddress, epochId } = req.body;
        // Update reward_entries status to 'distributed' or 'claimed'
        // For now, valid response
        res.json({ success: true });
    } catch (e) { res.status(500).json({ error: e.message }); }
});

/**
 * POST /api/vip/mark-claimed
 */
app.post('/api/vip/mark-claimed', async (req, res) => {
    try {
        res.json({ success: true });
    } catch (e) { res.status(500).json({ error: e.message }); }
});

// Helper: Handle Referral Logic
async function handleReferral(userAddress, referralCode, depositId) {
    try {
        // 1. Find Referrer by Code
        const { data: referrerUser } = await supabase
            .from('users')
            .select('wallet_address, referrer_address')
            .eq('referral_code', referralCode)
            .single();

        if (!referrerUser) return; // Invalid code, skip

        const referrerAddress = referrerUser.wallet_address;
        
        // Prevent self-referral
        if (referrerAddress.toLowerCase() === userAddress.toLowerCase()) return;

        // 2. Insert Level 1 Referral
        await supabase.from('referrals').insert({
            deposit_id: depositId,
            user_address: userAddress,
            referrer_address: referrerAddress,
            level: 1,
            status: 'pending'
        });

        // 3. Insert Level 2 Referral (if referrer has a referrer)
        if (referrerUser.referrer_address) {
            await supabase.from('referrals').insert({
                deposit_id: depositId,
                user_address: userAddress,
                referrer_address: referrerUser.referrer_address,
                level: 2,
                status: 'pending'
            });
        }
        
        // 4. Update Referrer Link in Users Table (if not set)
        await supabase
            .from('users')
            .update({ referrer_address: referrerAddress })
            .eq('wallet_address', userAddress)
            .is('referrer_address', null); // Only set if empty

    } catch (error) {
        console.error('Referral handling error:', error);
    }
}

app.listen(PORT, () => {
    console.log(`ðŸš€ API Server running on port ${PORT}`);
    console.log(`âœ… Manual Deposit System Active`);
});
